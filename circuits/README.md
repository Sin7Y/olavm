# OlaVM circuits
This crate contains three main modules: OlaVM starks, OlaVM prover and OlaVM verifier.  OlaVM starks describe what traces look like after programs executed by OlaVM executor and how to generate traces with products of OlaVM executor. OlaVM prover generates proofs of traces of execution by OlaVM executor, proving all traces are correct. OlaVM verifier verifies proofs generates by OlaVM prover, and all proofs passes means programs are correctly executed by OlaVM.

## Starks
The starks generate traces from execution of programs by [OlaVM executor](../executor/). There are 3 types of starks in Olavm:
* [CPU](./src/cpu/) -- check and constrain all CPU logic, e.g. `ADD`, `JMP`, `RET` etc.
* [RAM](./src/memory) -- check and constrain all memory logic, e.g. memory consistency.
* [Builtin](./src/builtins/) -- plugin modules that has specific scenarios, e.g. `AND`, `RangeCheck` etc.

## Prover
The prover uses traces of starks and then relies on the custom Plonky2 prover to generate STARK proofs.

## Verifier
The verifier verifies STARK proofs generated by OlaVM prover. If programs are executed correctly, the verifier
will pass all checks.

## Usage
This crate exposes two functions called `prove()` and `prove_with_traces`. After the OlaVM executor executes programs, the `prove()` function can be used to generate traces and proofs of their execution. If there already are all traces, the `prove_with_traces` function can be used to just generate proofs of their execution. 

The `prove` function takes the following parameters:

* `all_stark: &AllStark` - a reference to an AllStark struct contains all starks defined by OlaVM.
* `config: &StarkConfig` - a reference to a OlaVM STARK config, all parameters for proof generation
are configurable, and OlaVM has already provided a standard configuration.
* `inputs: GenerationInputs` - a set of inputs with which to execute the program.
* `timing: &mut TimingTree` - a reference to a tool to calculate the time consumed by each one scope. 

The function returns a Result enum to indicate if the program is executed. If true, an AllProof struct 
if wrapped in the result with two elements:

* `stark_proofs: [StarkProof<F, C, D>; NUM_TABLES]` - proof of program execution. a `StarkProof` corresponds to one stark.
* `public_values: PublicValues` - public inputs for executing programs.

The `prove_with_traces` function takes one more parameter than the `prove` function:

* `trace_poly_values: [Vec<PolynomialValues<F>>; NUM_TABLES]` - traces generated after programs are executed.


### Proof generation example
Here is a simple example of executing a program which calculates a fibonacci(8), prove the execution is correct by generating a proof and verifying the proofs:
```Rust
    // mov r0 8
    // mov r1 1
    // mov r2 1
    // mov r3 0
    // EQ r0 r3
    // cjmp 19
    // add r4 r1 r2
    // mov r1 r2
    // mov r2 r4
    // mov r4 1
    // add r3 r3 r4
    // jmp 8
    // end
    let program_src = "0x4000000840000000
        0x6000
        0x4000001040000000
        0x1
        0x4000002040000000
        0x1
        0x4000004040000000
        0x0
        0x0020800100000000
        0x4000000010000000
        0x13
        0x0040408400000000
        0x0000401040000000
        0x0001002040000000
        0x4000008040000000
        0x1
        0x0101004400000000
        0x4000000020000000
        0x8
        0x0000000000800000";

    let instructions = program_src.split('\n');
    let mut program: Program = Program {
        instructions: Vec::new(),
        trace: Default::default(),
    };

    // prepare the fibonacci program
    for inst in instructions.into_iter() {
        program.instructions.push(inst.clone().parse().unwrap());
    }

    // execute the fibonacci program
    let mut process = Process::new();
    process.execute(&mut program);
    

    // generate trace for all starks
    let (cpu_rows, cpu_beta) =
        generate_cpu_trace::<F>(&program.trace.exec, &program.trace.raw_binary_instructions);
    let cpu_trace = trace_rows_to_poly_values(cpu_rows);
    let memory_rows = generate_memory_trace::<F>(&program.trace.memory);
    let memory_trace = trace_rows_to_poly_values(memory_rows);
    let (bitwise_rows, bitwise_beta) =
        generate_builtins_bitwise_trace::<F>(&program.trace.builtin_bitwise_combined);
    let bitwise_trace = trace_rows_to_poly_values(bitwise_rows);
    let cmp_rows = generate_builtins_cmp_trace(&program.trace.builtin_cmp);
    let cmp_trace = trace_rows_to_poly_values(cmp_rows);
    let rangecheck_rows = generate_builtins_rangecheck_trace(&program.trace.builtin_rangecheck);
    let rangecheck_trace = trace_rows_to_poly_values(rangecheck_rows);
    let traces = [
        cpu_trace,
        memory_trace,
        bitwise_trace,
        cmp_trace,
        rangecheck_trace,
    ];

    // generate the proof with traces from the execution of the fibonacci program
    let all_stark = AllStark::default();
    let config = StarkConfig::standard_fast_config();
    let public_values = PublicValues::default();
    let proof = prove_with_traces::<F, C, D>(
        &all_stark,
        &config,
        traces,
        public_values,
        &mut TimingTree::default(),
    )?;

    // verify the proof is correct
    verify_proof(all_stark, proof, &config).unwrap();
```

### Concurrent proof generation
By default, the prover generates STARK proofs using multiple threads. For benefits of concurrent proof generation check out these [benchmarks](../README.md#Performance).

Internally, we use [rayon](https://github.com/rayon-rs/rayon) for parallel computations. To control the number of threads used to generate a STARK proof, you can use `RAYON_NUM_THREADS` environment variable.

## License

Licensed under either of

* Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
* MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)

at your option.